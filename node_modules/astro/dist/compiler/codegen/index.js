var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import eslexer from "es-module-lexer";
import esbuild from "esbuild";
import path from "path";
import astroParser from "@astrojs/parser";
import {walk, asyncWalk} from "estree-walker";
import _babelGenerator from "@babel/generator";
import babelParser from "@babel/parser";
import {codeFrameColumns} from "@babel/code-frame";
import * as babelTraverse from "@babel/traverse";
import {error, warn, parseError} from "../../logger.js";
import {yellow} from "kleur/colors";
import {isComponentTag, isCustomElementTag, positionAt} from "../utils.js";
import {renderMarkdown} from "@astrojs/markdown-support";
import {camelCase} from "camel-case";
import {transform} from "../transform/index.js";
import {PRISM_IMPORT} from "../transform/prism.js";
import {nodeBuiltinsSet} from "../../node_builtins.js";
import {readFileSync} from "fs";
import {pathToFileURL} from "url";
const {parse, FEATURE_CUSTOM_ELEMENT} = astroParser;
const traverse = babelTraverse.default.default;
const babelGenerator = _babelGenerator.default;
const {transformSync} = esbuild;
const hydrationDirectives = new Set(["client:load", "client:idle", "client:visible", "client:media"]);
function findHydrationAttributes(attrs) {
  let method;
  let value;
  for (const [key, val] of Object.entries(attrs)) {
    if (hydrationDirectives.has(key)) {
      method = key.slice(7);
      value = val === "true" ? void 0 : val;
    }
  }
  return {method, value};
}
async function getAttributes(attrs, state, compileOptions) {
  let result = {};
  for (const attr of attrs) {
    if (attr.type === "Spread") {
      const code = await compileExpression(attr.expression, state, compileOptions);
      if (code) {
        result[`...(${code})`] = "";
      }
      continue;
    }
    if (attr.value === true) {
      result[attr.name] = JSON.stringify(attr.value);
      continue;
    }
    if (attr.value === false || attr.value === void 0) {
      continue;
    }
    if (attr.value.length === 0) {
      result[attr.name] = '""';
      continue;
    }
    if (attr.value.length > 1) {
      result[attr.name] = "(" + attr.value.map((v) => {
        if (v.content) {
          return v.content;
        } else {
          return JSON.stringify(getTextFromAttribute(v));
        }
      }).join("+") + ")";
      continue;
    }
    const val = attr.value[0];
    if (!val) {
      result[attr.name] = "(" + val + ")";
      continue;
    }
    switch (val.type) {
      case "MustacheTag": {
        const code = await compileExpression(val.expression, state, compileOptions);
        if (code) {
          result[attr.name] = "(" + code + ")";
        }
        continue;
      }
      case "Text":
        result[attr.name] = JSON.stringify(getTextFromAttribute(val));
        continue;
      case "AttributeShorthand":
        result[attr.name] = "(" + attr.name + ")";
        continue;
      default:
        throw new Error(`UNKNOWN: ${val.type}`);
    }
  }
  return result;
}
function getTextFromAttribute(attr) {
  switch (attr.type) {
    case "Text": {
      if (attr.raw !== void 0) {
        return attr.raw;
      }
      if (attr.data !== void 0) {
        return attr.data;
      }
      break;
    }
    case "MustacheTag": {
      return attr.expression.codeChunks[0];
    }
  }
  throw new Error(`Unknown attribute type ${attr.type}`);
}
function generateAttributes(attrs) {
  let result = "{";
  for (const [key, val] of Object.entries(attrs)) {
    if (hydrationDirectives.has(key)) {
      continue;
    } else if (key.startsWith("...")) {
      result += key + ",";
    } else {
      result += JSON.stringify(key) + ":" + val + ",";
    }
  }
  result += `[__astroContext]:props[__astroContext]`;
  return result + "}";
}
function getComponentUrl(astroConfig, url, parentUrl) {
  const componentExt = path.extname(url);
  const ext = PlainExtensions.has(componentExt) ? ".js" : `${componentExt}.js`;
  const outUrl = new URL(url, parentUrl);
  return "/_astro/" + outUrl.href.replace(astroConfig.projectRoot.href, "").replace(/\.[^.]+$/, ext);
}
const PlainExtensions = new Set([".js", ".jsx", ".ts", ".tsx"]);
function getComponentWrapper(_name, hydration, {url, importSpecifier}, opts) {
  const {astroConfig, filename} = opts;
  let name = _name;
  let method = hydration.method;
  if (name.indexOf(":") > 0) {
    const [legacyName, legacyMethod] = _name.split(":");
    name = legacyName;
    method = legacyMethod;
    const {compileOptions, filename: filename2} = opts;
    const shortname = path.posix.relative(compileOptions.astroConfig.projectRoot.pathname, filename2);
    warn(compileOptions.logging, shortname, yellow(`Deprecation warning: Partial hydration now uses a directive syntax. Please update to "<${name} client:${method} />"`));
  }
  if (isCustomElementTag(_name)) {
    return {
      wrapper: `__astro_component(...__astro_element_registry.astroComponentArgs("${name}", ${JSON.stringify({hydrate: method, displayName: _name})}))`,
      wrapperImports: [
        `import {AstroElementRegistry} from 'astro/dist/internal/element-registry.js';`,
        `import {__astro_component} from 'astro/dist/internal/__astro_component.js';`
      ]
    };
  } else {
    const getComponentExport = () => {
      switch (importSpecifier.type) {
        case "ImportDefaultSpecifier":
          return {value: "default"};
        case "ImportSpecifier": {
          if (importSpecifier.imported.type === "Identifier") {
            return {value: importSpecifier.imported.name};
          }
          return {value: importSpecifier.imported.value};
        }
        case "ImportNamespaceSpecifier": {
          const [_, value] = _name.split(".");
          return {value};
        }
      }
    };
    let metadata = "";
    if (method) {
      const componentUrl = getComponentUrl(astroConfig, url, pathToFileURL(filename));
      const componentExport = getComponentExport();
      metadata = `{ hydrate: "${method}", displayName: "${name}", componentUrl: "${componentUrl}", componentExport: ${JSON.stringify(componentExport)}, value: ${hydration.value || "null"} }`;
    } else {
      metadata = `{ hydrate: undefined, displayName: "${name}", value: ${hydration.value || "null"} }`;
    }
    return {
      wrapper: `__astro_component(${name}, ${metadata})`,
      wrapperImports: [`import {__astro_component} from 'astro/dist/internal/__astro_component.js';`]
    };
  }
}
async function compileExpression(node, state, compileOptions) {
  var _a;
  const children = await Promise.all(((_a = node.children) != null ? _a : []).map((child) => compileHtml(child, state, compileOptions)));
  let raw = "";
  let nextChildIndex = 0;
  for (const chunk of node.codeChunks) {
    raw += chunk;
    if (nextChildIndex < children.length) {
      raw += children[nextChildIndex++];
    }
  }
  const location = {start: node.start, end: node.end};
  let code = transpileExpressionSafe("(" + raw + ")", {state, compileOptions, location});
  if (code === null)
    throw new Error(`Unable to compile expression`);
  code = code.trim().replace(/\;$/, "");
  return code;
}
function transpileExpressionSafe(raw, {state, compileOptions, location}) {
  try {
    let {code} = transformSync(raw, {
      loader: "tsx",
      jsxFactory: "h",
      jsxFragment: "Fragment",
      charset: "utf8"
    });
    return code;
  } catch ({errors}) {
    const err = new Error();
    const e = errors[0];
    err.filename = state.filename;
    const text = readFileSync(state.filename).toString();
    const start = positionAt(location.start, text);
    start.line += e.location.line;
    start.character += e.location.column + 1;
    err.start = {line: start.line, column: start.character};
    const end = __spreadValues({}, start);
    end.character += e.location.length;
    const frame = codeFrameColumns(text, {
      start: {line: start.line, column: start.character},
      end: {line: end.line, column: end.character}
    });
    err.frame = frame;
    err.message = e.text;
    parseError(compileOptions.logging, err);
    return null;
  }
}
function compileModule(ast, module, state, compileOptions) {
  var _a, _b;
  const {astroConfig} = compileOptions;
  const {filename} = state;
  const componentImports = [];
  const componentProps = [];
  const componentExports = [];
  let script = "";
  let propsStatement = "";
  let createCollection = "";
  if (module) {
    const parseOptions = {
      sourceType: "module",
      plugins: ["jsx", "typescript", "topLevelAwait", "throwExpressions"]
    };
    let parseResult;
    try {
      parseResult = babelParser.parse(module.content, parseOptions);
    } catch (err) {
      const location2 = {start: err.loc};
      const frame = codeFrameColumns(module.content, location2);
      err.frame = frame;
      err.filename = state.filename;
      err.start = err.loc;
      throw err;
    }
    if (/Astro\s*\.\s*fetchContent/.test(module.content)) {
      state.importStatements.add(`import {fetchContent} from 'astro/dist/internal/fetch-content.js';
`);
      traverse(parseResult, {
        enter({node}) {
          if (node.type !== "CallExpression" || node.callee.type !== "MemberExpression" || node.callee.object.name !== "Astro" || node.callee.property.name !== "fetchContent") {
            return;
          }
          if (node.arguments[0].type !== "StringLiteral") {
            throw new Error(`[Astro.fetchContent] Only string literals allowed, ex: \`Astro.fetchContent('./post/*.md')\`
  ${state.filename}`);
          }
          node.arguments = [
            {
              type: "CallExpression",
              callee: {
                type: "MemberExpression",
                object: {type: "MetaProperty", meta: {type: "Identifier", name: "import"}, property: {type: "Identifier", name: "meta"}},
                property: {type: "Identifier", name: "globEager"},
                computed: false
              },
              arguments: node.arguments
            }
          ];
        }
      });
    }
    const program = parseResult.program;
    const {body} = program;
    let i = body.length;
    while (--i >= 0) {
      const node = body[i];
      switch (node.type) {
        case "ExportNamedDeclaration": {
          if (!node.declaration)
            break;
          if (node.declaration.type === "VariableDeclaration") {
            const declaration = node.declaration.declarations[0];
            if (declaration.id.name === "__layout" || declaration.id.name === "__content") {
              componentExports.push(node);
            } else {
              componentProps.push(declaration);
            }
          } else if (node.declaration.type === "FunctionDeclaration") {
            if (!node.declaration.id || node.declaration.id.name !== "createCollection")
              break;
            createCollection = babelGenerator(node).code;
          }
          body.splice(i, 1);
          break;
        }
        case "FunctionDeclaration": {
          if ((_a = node.id) == null ? void 0 : _a.name) {
            state.declarations.add((_b = node.id) == null ? void 0 : _b.name);
          }
          break;
        }
        case "ImportDeclaration": {
          componentImports.push(node);
          body.splice(i, 1);
          break;
        }
        case "VariableDeclaration": {
          for (const declaration of node.declarations) {
            if (declaration.id.type === "Identifier") {
              state.declarations.add(declaration.id.name);
            }
          }
          break;
        }
      }
    }
    for (const componentImport of componentImports) {
      const importUrl = componentImport.source.value;
      if (nodeBuiltinsSet.has(importUrl)) {
        throw new Error(`Node builtins must be prefixed with 'node:'. Use node:${importUrl} instead.`);
      }
      for (const specifier of componentImport.specifiers) {
        const componentName = specifier.local.name;
        state.components.set(componentName, {
          importSpecifier: specifier,
          url: importUrl
        });
      }
      const {start, end} = componentImport;
      if (ast.meta.features & FEATURE_CUSTOM_ELEMENT && componentImport.specifiers.length === 0) {
        const moduleImportName = camelCase(importUrl + "Module");
        state.importStatements.add(`import * as ${moduleImportName} from '${importUrl}';
`);
        state.customElementCandidates.set(moduleImportName, getComponentUrl(astroConfig, importUrl, pathToFileURL(filename)));
      } else {
        state.importStatements.add(module.content.slice(start || void 0, end || void 0));
      }
    }
    for (const componentImport of componentExports) {
      const {start, end} = componentImport;
      state.exportStatements.add(module.content.slice(start || void 0, end || void 0));
    }
    if (componentProps.length > 0) {
      const shortname = path.posix.relative(compileOptions.astroConfig.projectRoot.pathname, state.filename);
      const props = componentProps.map((prop) => {
        var _a2;
        return (_a2 = prop.id) == null ? void 0 : _a2.name;
      }).filter((v) => v);
      warn(compileOptions.logging, shortname, yellow(`
Defining props with "export" has been removed! Please see https://github.com/snowpackjs/astro/blob/main/packages/astro/CHANGELOG.md#0150
Please update your code to use:

const { ${props.join(", ")} } = Astro.props;
`));
    }
    script = propsStatement + babelGenerator(program).code;
    const location = {start: module.start, end: module.end};
    let transpiledScript = transpileExpressionSafe(script, {state, compileOptions, location});
    if (transpiledScript === null)
      throw new Error(`Unable to compile script`);
    script = transpiledScript;
  }
  return {
    script,
    createCollection: createCollection || void 0
  };
}
function compileCss(style, state) {
  walk(style, {
    enter(node) {
      if (node.type === "Style") {
        state.css.push(node.content.styles);
        this.skip();
      }
    },
    leave(node) {
      if (node.type === "Style") {
        this.remove();
      }
    }
  });
}
function dedent(str) {
  var _a;
  let arr = str.match(/^[ \t]*(?=\S)/gm);
  let first = !!arr && ((_a = arr.find((x) => x.length > 0)) == null ? void 0 : _a.length);
  return !arr || !first ? str : str.replace(new RegExp(`^[ \\t]{0,${first}}`, "gm"), "");
}
const FALSY_EXPRESSIONS = new Set(["false", "null", "undefined", "void 0"]);
function isFrontmatterDefinedComponent(componentName, componentInfo, state) {
  let hasVariableDeclaration = state.declarations.has(componentName);
  let isNotImported = !componentInfo;
  return hasVariableDeclaration && isNotImported;
}
function isFragmentComponent(componentName) {
  return componentName === "Fragment";
}
async function compileHtml(enterNode, state, compileOptions) {
  return new Promise((resolve) => {
    const {components, css, importStatements, exportStatements, filename, fileID} = state;
    const {astroConfig} = compileOptions;
    let paren = -1;
    let buffers = {
      out: "",
      markdown: ""
    };
    let curr = "out";
    async function pushMarkdownToBuffer() {
      const md = buffers.markdown;
      const {markdownOptions = {}} = astroConfig;
      if (!md.trim()) {
        buffers.out += "," + md;
        buffers.markdown = "";
        curr = "out";
        return;
      }
      const {$scope: scopedClassName} = state.markers.insideMarkdown;
      let {content: rendered} = await renderMarkdown(dedent(md), __spreadProps(__spreadValues({}, markdownOptions), {
        $: {scopedClassName: scopedClassName && scopedClassName.slice(1, -1)}
      }));
      const ast = parse(rendered);
      await transform(ast, {
        compileOptions,
        filename,
        fileID
      });
      const result = await compileHtml(ast.html, __spreadProps(__spreadValues({}, state), {markers: {insideMarkdown: false}}), compileOptions);
      buffers.out += "," + result;
      buffers.markdown = "";
      curr = "out";
    }
    asyncWalk(enterNode, {
      async enter(node, parent) {
        switch (node.type) {
          case "Expression": {
            let code = await compileExpression(node, state, compileOptions);
            if (FALSY_EXPRESSIONS.has(code)) {
              this.skip();
              break;
            }
            if (code !== "") {
              if (state.markers.insideMarkdown) {
                buffers[curr] += `{${code}}`;
              } else {
                buffers[curr] += `,(${code})`;
              }
            }
            this.skip();
            break;
          }
          case "MustacheTag":
            if (state.markers.insideMarkdown) {
              if (curr === "out")
                curr = "markdown";
            }
            return;
          case "Comment":
            return;
          case "Fragment": {
            buffers[curr] += `h(Fragment, null,`;
            break;
          }
          case "SlotTemplate": {
            buffers[curr] += `h(Fragment, null, children`;
            paren++;
            return;
          }
          case "Slot":
          case "Head":
          case "InlineComponent": {
            switch (node.name) {
              case "Prism": {
                if (!importStatements.has(PRISM_IMPORT)) {
                  importStatements.add(PRISM_IMPORT);
                }
                if (!components.has("Prism")) {
                  components.set("Prism", {
                    importSpecifier: {
                      type: "ImportDefaultSpecifier",
                      local: {type: "Identifier", name: "Prism"}
                    },
                    url: "astro/components/Prism.astro"
                  });
                }
                break;
              }
            }
          }
          case "Title":
          case "Element": {
            const name = node.name;
            if (!name) {
              throw new Error("AHHHH");
            }
            try {
              const attributes = await getAttributes(node.attributes, state, compileOptions);
              const hydrationAttributes = findHydrationAttributes(attributes);
              buffers.out += buffers.out === "" ? "" : ",";
              if (node.type === "Slot") {
                state.importStatements.add(`import { __astro_slot } from 'astro/dist/internal/__astro_slot.js';`);
                buffers[curr] += `h(__astro_slot, ${generateAttributes(attributes)}, children`;
                paren++;
                return;
              }
              if (!isComponentTag(name)) {
                if (curr === "markdown") {
                  await pushMarkdownToBuffer();
                }
                if (attributes.slot) {
                  state.importStatements.add(`import { __astro_slot_content } from 'astro/dist/internal/__astro_slot.js';`);
                  buffers[curr] += `h(__astro_slot_content, { name: ${attributes.slot} },`;
                  paren++;
                }
                buffers[curr] += `h("${name}", ${generateAttributes(attributes)},`;
                paren++;
                return;
              }
              const [componentName, _componentKind] = name.split(":");
              let componentInfo = components.get(componentName);
              if (/\./.test(componentName)) {
                const [componentNamespace] = componentName.split(".");
                componentInfo = components.get(componentNamespace);
              }
              if (isFrontmatterDefinedComponent(componentName, componentInfo, state) && !isCustomElementTag(componentName) || isFragmentComponent(componentName)) {
                if (hydrationAttributes.method) {
                  throw new Error(`Unable to hydrate "${componentName}" because it is statically defined in the frontmatter script. Hydration directives may only be used on imported components.`);
                }
                if (curr === "markdown") {
                  await pushMarkdownToBuffer();
                }
                if (attributes.slot) {
                  state.importStatements.add(`import { __astro_slot_content } from 'astro/dist/internal/__astro_slot.js';`);
                  buffers[curr] += `h(__astro_slot_content, { name: ${attributes.slot} },`;
                  paren++;
                }
                buffers[curr] += `h(${componentName}, ${generateAttributes(attributes)},`;
                paren++;
                return;
              } else if (!componentInfo && !isCustomElementTag(componentName)) {
                throw new Error(`Unable to render "${componentName}" because it is undefined
  ${state.filename}`);
              }
              if (componentName === "Markdown") {
                const {$scope} = attributes != null ? attributes : {};
                state.markers.insideMarkdown = typeof state.markers.insideMarkdown === "object" ? {$scope, count: state.markers.insideMarkdown.count + 1} : {$scope, count: 1};
                const keys = Object.keys(attributes).filter((attr) => attr !== "$scope");
                if (keys.length > 0) {
                  if (curr === "markdown") {
                    await pushMarkdownToBuffer();
                  }
                  buffers[curr] += `,${componentName}.__render(${generateAttributes(attributes)}),`;
                }
                curr = "markdown";
                return;
              }
              const {wrapper, wrapperImports} = getComponentWrapper(name, hydrationAttributes, componentInfo != null ? componentInfo : {}, {astroConfig, filename, compileOptions});
              if (wrapperImports) {
                for (let wrapperImport of wrapperImports) {
                  importStatements.add(wrapperImport);
                }
              }
              if (curr === "markdown") {
                await pushMarkdownToBuffer();
              }
              if (attributes.slot) {
                state.importStatements.add(`import { __astro_slot_content } from 'astro/dist/internal/__astro_slot.js';`);
                buffers[curr] += `h(__astro_slot_content, { name: ${attributes.slot} },`;
                paren++;
              }
              paren++;
              buffers[curr] += `h(${wrapper}, ${generateAttributes(attributes)}`;
            } catch (err) {
              paren--;
              const rel = filename.replace(astroConfig.projectRoot.pathname, "");
              error(compileOptions.logging, rel, err.toString());
            }
            return;
          }
          case "Attribute":
          case "Spread": {
            this.skip();
            return;
          }
          case "Style": {
            css.push(node.content.styles);
            this.skip();
            return;
          }
          case "CodeSpan":
          case "CodeFence": {
            if (state.markers.insideMarkdown) {
              if (curr === "out")
                curr = "markdown";
              buffers[curr] += node.raw;
              return;
            }
            buffers[curr] += "," + JSON.stringify(node.data);
            return;
          }
          case "Text": {
            let text = getTextFromAttribute(node);
            if (state.markers.insideMarkdown) {
              if (curr === "out")
                curr = "markdown";
              buffers[curr] += text;
              return;
            }
            if (parent.name !== "Markdown" && !text.trim()) {
              return;
            }
            if (parent.name === "code") {
              text = node.raw.replace(/&#x26;#123;/g, "{");
            }
            buffers[curr] += "," + JSON.stringify(text);
            return;
          }
          default:
            throw new Error("Unexpected (enter) node type: " + node.type);
        }
      },
      async leave(node, parent, prop, index) {
        switch (node.type) {
          case "Fragment": {
            buffers[curr] += `)`;
            break;
          }
          case "Text":
          case "Attribute":
          case "Spread":
          case "Comment":
          case "Expression":
          case "MustacheTag":
          case "CodeSpan":
          case "CodeFence":
            return;
          case "SlotTemplate":
          case "Slot":
          case "Head":
          case "Body":
          case "Title":
          case "Element": {
            if (curr === "markdown") {
              await pushMarkdownToBuffer();
            }
            if (node.attributes.find((attr) => attr.name === "slot")) {
              buffers.out += ")";
              paren--;
            }
            if (paren !== -1) {
              buffers.out += ")";
              paren--;
            }
            return;
          }
          case "InlineComponent": {
            if (node.name === "Markdown") {
              state.markers.insideMarkdown.count--;
              if (state.markers.insideMarkdown.count <= 0) {
                state.markers.insideMarkdown = false;
              }
              const hasAttrs = node.attributes.filter(({name}) => name !== "$scope").length > 0;
              if (hasAttrs) {
                return;
              }
            }
            if (curr === "markdown" && buffers.markdown !== "") {
              await pushMarkdownToBuffer();
              if (!state.markers.insideMarkdown) {
                return;
              }
            }
            if (node.attributes.find((attr) => attr.name === "slot")) {
              buffers.out += ")";
              paren--;
            }
            if (paren !== -1) {
              buffers.out += ")";
              paren--;
            }
            return;
          }
          case "Style": {
            this.remove();
            return;
          }
          default:
            throw new Error("Unexpected (leave) node type: " + node.type);
        }
      }
    }).then(() => {
      const content = buffers.out.replace(/^\,/, "").replace(/\,\)/g, ")").replace(/\,+/g, ",").replace(/\)h/g, "),h");
      buffers.out = "";
      buffers.markdown = "";
      return resolve(content);
    });
  });
}
async function codegen(ast, {compileOptions, filename, fileID}) {
  await eslexer.init;
  const state = {
    filename,
    fileID,
    components: new Map(),
    css: [],
    markers: {
      insideMarkdown: false
    },
    declarations: new Set(),
    importStatements: new Set(),
    exportStatements: new Set(),
    customElementCandidates: new Map()
  };
  const {script, createCollection} = compileModule(ast, ast.module, state, compileOptions);
  (ast.css || []).map((css) => compileCss(css, state));
  const html = await compileHtml(ast.html, state, compileOptions);
  return {
    script,
    imports: Array.from(state.importStatements),
    exports: Array.from(state.exportStatements),
    html,
    css: state.css.length ? state.css.join("\n\n") : void 0,
    createCollection,
    hasCustomElements: Boolean(ast.meta.features & FEATURE_CUSTOM_ELEMENT),
    customElementCandidates: state.customElementCandidates
  };
}
export {
  codegen
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vc3JjL2NvbXBpbGVyL2NvZGVnZW4vaW5kZXgudHMiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxNQUFNLENBQUUsT0FBTywwQkFBMkI7QUFDMUMsTUFBTSxXQUEwQyxjQUFjLFFBQWdCO0FBRzlFLE1BQU0saUJBQXlDLGdCQUFnQjtBQUMvRCxNQUFNLENBQUUsaUJBQWtCO0FBRTFCLE1BQU0sc0JBQXNCLElBQUksSUFBSSxDQUFDLGVBQWUsZUFBZSxrQkFBa0I7QUF1QnJGLGlDQUFpQyxPQUFvRDtBQUNuRixNQUFJO0FBQ0osTUFBSTtBQUVKLGFBQVcsQ0FBQyxLQUFLLFFBQVEsT0FBTyxRQUFRLFFBQVE7QUFDOUMsUUFBSSxvQkFBb0IsSUFBSSxNQUFNO0FBQ2hDLGVBQVMsSUFBSSxNQUFNO0FBQ25CLGNBQVEsUUFBUSxTQUFTLFNBQVk7QUFBQTtBQUFBO0FBSXpDLFNBQU8sQ0FBRSxRQUFRO0FBQUE7QUFJbkIsNkJBQTZCLE9BQW9CLE9BQXFCLGdCQUFpRTtBQUNySSxNQUFJLFNBQWlDO0FBQ3JDLGFBQVcsUUFBUSxPQUFPO0FBQ3hCLFFBQUksS0FBSyxTQUFTLFVBQVU7QUFDMUIsWUFBTSxPQUFPLE1BQU0sa0JBQWtCLEtBQUssWUFBMEIsT0FBTztBQUMzRSxVQUFJLE1BQU07QUFDUixlQUFPLE9BQU8sV0FBVztBQUFBO0FBRTNCO0FBQUE7QUFFRixRQUFJLEtBQUssVUFBVSxNQUFNO0FBQ3ZCLGFBQU8sS0FBSyxRQUFRLEtBQUssVUFBVSxLQUFLO0FBQ3hDO0FBQUE7QUFFRixRQUFJLEtBQUssVUFBVSxTQUFTLEtBQUssVUFBVSxRQUFXO0FBRXBEO0FBQUE7QUFFRixRQUFJLEtBQUssTUFBTSxXQUFXLEdBQUc7QUFDM0Is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
